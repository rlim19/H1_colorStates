\documentclass{article}
\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{url}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{
 pdfstartview={XYZ null null 1}}
\usepackage{breakurl}
\begin{document}

<<setup, include=FALSE, cache=FALSE>>=
# set global chunk options
# for figures
opts_chunk$set(fig.path='figs/', fig.align='center', fig.show='hold',dev='CairoPDF', out.width='.4\\linewidth')
# replacing "=" into "->" to make it R thing
options(replace.assign=TRUE,width=90)
# caching chunks
opts_chunk$set(cache.extra = R.version,cache.path='cache/')
opts_chunk$set(cache.extra = rand_seed)
@

\author{Ricky Lim}
\title{Four-state HMM:Analysis}
\maketitle

\begin{verbatim}
  Filename: 4StateAnalysis.Rnw 
  Working directory: \Sexpr{getwd()} 
\end{verbatim}

\section{Goal}
\begin{itemize}
  \item Analyse the parameters of the four-state HMM
\end{itemize}

\section{Load Datasets}
Dataset was generated by G.Filion. In this dataset, it contains:\\
\begin{itemize}                                                                                    
  \item Q: The transition matrix
  \item B: the emission matrix
  \item vPath: the fitted viterbi path
  \item emissionProb: the emission prob of each loci. In 3000bin-size, the coverage is 1031884 bins
\end{itemize}

<<fit4HMM, cache=TRUE>>=
load('input/fit41366702728.rda')
ls()
print (names(fit4))
@

\section{Emission and Transition Matrix}
\subsection{Emission}
<<Emission, eval=FALSE, cache=TRUE>>=
em <- fit4$B
head(em)
colnames(em) <- c('Red', 'Pink', 'Yellow', 'Black')

library(gplots)
get_heatMat <- function(mat_, margins, Colv, Rowv, cutZero){
  # construct heatmap, given a matrix
  heatmap.2(mat_, col=cm.colors(256), 
            Colv=Colv, Rowv=Rowv,
            dendrogram="none", trace="none",
            density.info = 'none',scale="none",
             keysize=0.8, margins = margins,
            symbreaks=cutZero)
}

pdf('figs/em_matrix.pdf', useDingbats = FALSE)
HeatMapEm <- get_heatMat(em, margins=c(5,10), Colv=NA, Rowv=TRUE, cutZero=FALSE)
dev.off()

@

\begin{figure}
  \centering
  \includegraphics {figs/em_matrix.pdf}
  \caption {Emission Matrix}
\end{figure}

\subsection{Transition Matrix}
<<Transition, eval=FALSE, cache=TRUE>>=
trans <- fit4$Q
colnames(trans) <- c('Red', 'Pink', 'Yellow', 'Black')
rownames(trans) <- c('Red', 'Pink', 'Yellow', 'Black')

pdf('figs/trans_matrix.pdf', useDingbats=FALSE)
HeatMapTrans <- get_heatMat(trans, margins=c(5,5), Colv=NA, Rowv=NA, cutZero=FALSE)
dev.off()

@

\begin{figure}
  \centering
  \includegraphics {figs/trans_matrix.pdf}
  \caption {Transition Matrix}
\end{figure}

\section{Enrichment over genome average}                                                                                   

<<EnrichmentOverGenomeAverage,eval=FALSE, cache=TRUE>>=

get_enrichmentPerGenomeAverage <- function(em_mat, fit_object){
  
  # input: emmision matrix
  # fit_object: fit object run from BaumWelch() function in chromHMMatin
  averagePerState <- table(fit_object$vPath)/sum(table(fit_object$vPath))
  marksPerGenomeAverage <- em_mat %*% averagePerState
  mat_perGenomeAverage <- sweep(em_mat, 1,  marksPerGenomeAverage, "/" )
  return(mat_perGenomeAverage)
  
}

em_GenomeAverage <- get_enrichmentPerGenomeAverage(em, fit4)
get_heatMat(log(em_GenomeAverage), Colv=NA, Rowv=TRUE,margins=c(5,10), cutZero=TRUE)

#thresholding the enrichment for 10 profiles
em_GenomeAverage_thresholded <- em_GenomeAverage
em_GenomeAverage_thresholded[em_GenomeAverage_thresholded < 1e-6] <- 1e-6

pdf('figs/enrich_matrix.pdf', useDingbats=FALSE)
get_heatMat(log(em_GenomeAverage_thresholded), Colv=NA, Rowv=TRUE,margins=c(5,10), cutZero=TRUE)
dev.off()

@


\begin{figure}
  \centering
  \includegraphics {figs/enrich_matrix.pdf}
  \caption {Enrichment Matrix}
\end{figure}

\section{Coverage of Each Profile}
Coverage of each profile was analysed as follows. The binary matrix consists of 0 and 1 that corresponds to non-target and target from all the profiles was used as input. For each profile, the coverage for each state is evaluated as the mean of the targets (1) for each state. The average genome-wide for each profile, defined as GW, was computed as the mean of the targets across the whole states or in this case along the genome. 

<<CoverageProfile, cache=TRUE, eval=FALSE>>=
coverage_data <- read.delim('input/discretized_with_NAs.txt.gz')
head(coverage_data)
coverage_data[1:5,1:5]
dim(coverage_data)
# get the color state
state <- fit4$vPath
# exclude the chr column
coverage_data <- coverage_data[, c(2:69)] 
# combine it with the color state
coverage_data <- cbind(coverage_data, state)
# remove the NAs
coverage_data <- coverage_data[complete.cases(coverage_data), ]
# get only the profiles without the color state
coverage_mat <- coverage_data[, c(1:68)]
# compute the genome-wide average of each profile
GW <- apply(coverage_mat, 2, mean)

library(plyr)

# compute the average of each state for each profile
mean_state <- aggregate(.~state, data=coverage_data, FUN=mean)
head(mean_state)
mean_state[1:4,1:4]
# exclude the first column -> the state's info
coverage_state <- mean_state[,2:ncol(mean_state)]
# combine it with the genome-wide average
coverage_profiles <- rbind(coverage_state, GW)
head(coverage_profiles)
rownames(coverage_profiles) <- c('Red','Pink', 'Yellow','Black',"GW")
coverage_profiles <- t(coverage_profiles)

pdf('figs/coverage_matrix.pdf', useDingbats=FALSE)
get_heatMat(coverage_profiles, Colv=NA, Rowv=TRUE, margins=c(4,10), cutZero=FALSE)
dev.off()
@


\begin{figure}
  \centering
  \includegraphics {figs/coverage_matrix.pdf}
  \caption {Coverage Matrix}
\end{figure}


\pagebreak
\section{Metainfo}
<<>>=
sessionInfo()
@

<<knitIt, cache=TRUE, echo=FALSE, error=FALSE, results='hide', message=FALSE, warning=FALSE>>=
library(knitr)
knit("4StateAnalysis.Rnw" ) # compile to tex
purl("4StateAnalysis.Rnw", documentation = 0) # extract R code only
knit2pdf("4StateAnalysis.Rnw")
@

\end{document}

